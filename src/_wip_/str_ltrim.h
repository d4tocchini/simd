
// TODO: WIP
static const char mi128_str_ltrim_lut[] = {
    0x0, 0x1, 0x2, 0x3,  0x4, 0x5, 0x6, 0x7,  0x8, 0x9, 0xa, 0xb,  0xc, 0xd, 0xe, 0xf,
    0x1, 0x2, 0x3, 0x4,  0x5, 0x6, 0x7, 0x8,  0x9, 0xa, 0xb, 0xc,  0xd, 0xe, 0xf, 0xf,
    0x0, 0x2, 0x3, 0x4,  0x5, 0x6, 0x7, 0x8,  0x9, 0xa, 0xb, 0xc,  0xd, 0xe, 0xf, 0xf,
    0x2, 0x3, 0x4, 0x5,  0x6, 0x7, 0x8, 0x9,  0xa, 0xb, 0xc, 0xd,  0xe, 0xf, 0xf, 0xf,

    0x0, 0x1, 0x3, 0x4,  0x5, 0x6, 0x7, 0x8,  0x9, 0xa, 0xb, 0xc,  0xd, 0xe, 0xf, 0xf,
    0x1, 0x3, 0x4, 0x5,  0x6, 0x7, 0x8, 0x9,  0xa, 0xb, 0xc, 0xd,  0xe, 0xf, 0xf, 0xf,
    0x0, 0x3, 0x4, 0x5,  0x6, 0x7, 0x8, 0x9,  0xa, 0xb, 0xc, 0xd,  0xe, 0xf, 0xf, 0xf,
    0x3, 0x4, 0x5, 0x6,  0x7, 0x8, 0x9, 0xa,  0xb, 0xc, 0xd, 0xe,  0xf, 0xf, 0xf, 0xf,
    0x0, 0x1, 0x2, 0x4,  0x5, 0x6, 0x7, 0x8,  0x9, 0xa, 0xb, 0xc,  0xd, 0xe, 0xf, 0xf,
    0x0, 0x1, 0x2, 0x3,  0x5, 0x6, 0x7, 0x8,  0x9, 0xa, 0xb, 0xc,  0xd, 0xe, 0xf, 0xf,
    0x0, 0x1, 0x2, 0x3,  0x4, 0x6, 0x7, 0x8,  0x9, 0xa, 0xb, 0xc,  0xd, 0xe, 0xf, 0xf,
    0x0, 0x1, 0x2, 0x3,  0x4, 0x5, 0x7, 0x8,  0x9, 0xa, 0xb, 0xc,  0xd, 0xe, 0xf, 0xf,
    0x0, 0x1, 0x2, 0x3,  0x4, 0x5, 0x6, 0x8,  0x9, 0xa, 0xb, 0xc,  0xd, 0xe, 0xf, 0xf,
    0x0, 0x1, 0x2, 0x3,  0x4, 0x5, 0x6, 0x7,  0x9, 0xa, 0xb, 0xc,  0xd, 0xe, 0xf, 0xf,
    0x0, 0x1, 0x2, 0x3,  0x4, 0x5, 0x6, 0x7,  0x8, 0xa, 0xb, 0xc,  0xd, 0xe, 0xf, 0xf,
    0x0, 0x1, 0x2, 0x3,  0x4, 0x5, 0x6, 0x7,  0x8, 0x9, 0xb, 0xc,  0xd, 0xe, 0xf, 0xf,
    0x0, 0x1, 0x2, 0x3,  0x4, 0x5, 0x6, 0x7,  0x8, 0x9, 0xa, 0xb,  0xc, 0xd, 0xe, 0xf,
    0x0, 0x1, 0x2, 0x3,  0x4, 0x5, 0x6, 0x7,  0x8, 0x9, 0xa, 0xb,  0xc, 0xd, 0xe, 0xf
};


static inline size_t str_ltrim(char* buf, size_t len) {
    const mi128 spaces = simde_mm_set1_epi8(' ');  
    size_t pos = 0;  
    size_t i = 0;  
    int done = 0; 
    for (; i + 15 < len; i += 16) {
        mi128 x = simde_mm_loadu_si128((const mi128 *)(buf + i));
        mi128 anywhite = simde_mm_cmpeq_epi8(spaces, simde_mm_max_epu8(spaces, x));
        uint32_t mask16 = simde_mm_movemask_epi8(anywhite) * (done ^ 1);    
    
        // printf("mask\t%i,\tppc %i,\tctz %i,\tclz %i\n",mask16,_mm_popcnt_u32(mask16),u32_ctz(mask16),__builtin_clz(mask16));        
        // puts("");
        // printf("mask= %i , trailing 1s %i",mask16,u16_trailing_1s(mask16));
        // puts("");

        u16 t1s = u16_trailing_1s(mask16) ;        
        // if (tls == 16) 
        if (t1s > 0) {                        
            done = 1;
            x = simde_mm_shuffle_epi8(x, *((mi128 *)mi128_str_ltrim_lut + (0b111 & 0x7fff)));
            simde_mm_storeu_si128((mi128 *)(buf + pos), x);
        }
        pos += 16 - t1s;
    }
 
    while (i < len) {
        const char c = buf[i++];        
        buf[pos++] = c;        
    }
    
    if (pos < len) 
        buf[pos] = 0;

    //   while (pos < len) 
    //       buf[pos++] = ' ';      

    return pos;
}
static inline size_t str_ltrim_(char* buf) {
    return str_ltrim(buf, strlen(buf));
}


